---
date: 2024-04-04 10:33:40
layout: post
title: "객체지향프로그래밍(24) - 형변환의 모든 것"
subtitle: "기본 자료형과 클래스간 형변환"
description: 기본 자료형과 클래스간의 형변환을 이해한다.
image: https://res.cloudinary.com/dtloik0ts/image/upload/v1710305020/62209a189cc9185b70db045b_6ea4ua9rZnloCziXgO4TM7Zqa5oWwYrMD4Lc5BqWGYHrJreJ0-Cq-VTOChRhm1IEhqCGeGpQh9M8L516rerUQF9l1FnfQaHEFyTzex7ily50AmFoRns3jMWLyd5edWCJqBbqGzvo_xaa8bg.jpg
optimized_image: https://res.cloudinary.com/dtloik0ts/image/upload/t_opt/v1710305020/62209a189cc9185b70db045b_6ea4ua9rZnloCziXgO4TM7Zqa5oWwYrMD4Lc5BqWGYHrJreJ0-Cq-VTOChRhm1IEhqCGeGpQh9M8L516rerUQF9l1FnfQaHEFyTzex7ily50AmFoRns3jMWLyd5edWCJqBbqGzvo_xaa8bg.jpg
category: 객체지향프로그래밍
tags:
  - 정리
  - 객체지향프로그래밍
author: Minsu Choi
paginate: false
---

<h2>🔚 짧게 하는 복습</h2>

✅ 1. 산술 대입연산자의 오버로딩을 할 수 있다.

✅ 2. 조건 연산자의 오버로딩을 할 수 있다.

✅ 3. 그 밖에도 다른 연산자들도 오버로딩을 할 수 있다.

혹시 기억이 안 난다면, <u><a href = "/객체지향프로그래밍(23)-연산자-오버로딩(2),-산술대입연산자와-조건-연산자/"> 다시 돌아가자</a></u>

---

우리는 이때까지 크게 총 2가지 형태의 형변환을 다루었다.

하나는 **기본 자료형 간의 형변환**, 이는 C와 C++에서 **언어적 차원으로 암시적, 혹은 명시적 캐스팅**을 통해 제공했다.

두 번째는 **상속된 클래스 간의 형변환**, 이는 **업 캐스팅과 다운 캐스팅(dynamic_cast)**를 통해서 할 수 있었다.

오늘 배울 내용은 정말 형변환의 끝을 보기 위해 준비했다.

아직 우리가 다루지 않은 형변환의 형태는 총 4가지.

1. 기본 자료형 -> 클래스

2. 클래스 -> 기본 자료형

3. 클래스 -> 다른 클래스(1)

4. 클래스 -> 다른 클래스(2)

이렇게 하는 것으로 다루어 보겠다.

책의 예제 코드가 훌륭해서, 참고해서 강의해보겠다.

**참고로 이 문서가 궁금한 사람은 *읽어볼 거리*에 링크를 남기겠다.**

---

## 1. 기본 자료형 -> 클래스

이는 단순히 생각해봤을 때도 하나밖에 결론이 없다.

생성자를 통해서 하면 되는 것이다.

암시적이든 명시적이든 생성자를 호출시키는 방법을 사용하면 된다.

우리가 지금까지 본 많은 코드에서 사용되었다.

저번 시간 코드 중, 이런게 있었다.

```c++
cnt += 3;
```

이는 사실 아래와 같다고 했다.

```c++
cnt += counter(3);
```

위처럼 사용하면 암시적 형변환, 아래처럼 사용하면 명시적 형변환이라는 차이가 있을 뿐이다.

---

## 2. 클래스 -> 기본 자료형

이는 가장 단순한 생각으로는 기본 자료형의 명시적 형변환을 쓰면 좋을 것 같다.

```c++
int count = (int)cnt
```

하지만, 조금만 더 생각해보면 멤버 변수가 하나가 아닐 수도 있다.

그렇기에 **반환 연산자**라는 것을 사용해야 한다.

**반환 연산자**란 **기본자료형() 꼴로 연산자**를 만들면, **멤버 변숫값을 계산하여 하나의 원하는 자료형 값으로 반환되는 연산자**이다.

예를 들어, 오랜만에 다시 포켓몬 게임에서는 체급을 나타내는 말이 있다.

종합 능력치를 다 더해서 백 단위로 등급을 매긴다.

bukein() : name("브케인"), type(Fire), hp(450), attack(45), defend(10), mobility(20), skill({ 8, 50 })

이 체급의 포켓몬 브케인은 450 + 45 + 10 + 20 + 8 + 50 = 588으로, **등급 5** 포켓몬이라고 한다.

이를 직접 구현해보자. 반환형이 int이니까 int()라고 반환 연산자를 정의해주면 된다. _(const로 함수 만드는 것을 잊지 말자)_

<iframe height="1500px" width="700px" src="https://www.interviewbit.com/embed/snippet/b88e0cf542241d219434"></iframe>

여기서 static_cast가 무엇인지 의아할 텐데, C++에서는 (int), (int\*)등 괄호를 통해 형변환 하는 것을 권장하지 않는다.

대부분 그래서 **기본 자료형 사이 형 변환할 때**나, **반환 연산자** 대신 호출하고 싶을 때 **static_cast**를 사용한다.

---

## 서로 다른 클래스 간 변환

여기가 굉장히 중요하고 헷갈린다.

두 가지 방법이 있는데 어느 곳에 변환하는 연산자를 놓느냐에 따라서 **생성자**가 될지, **반환 연산자**가 될지가 정해진다.

12진법을 사용하는 시계와 24진법을 사용하는 시계 두 가지를 서로 바꾸는 코드를 만들어보겠다.

우선 서로의 클래스는 시, 분, 초를 가지고 있고 그를 표현하는 display를 가진다.

아래의 코드를 보자. 첫 번째는 생성자를 통한 방법이다.

<iframe height="3000px" width="700px" src="https://www.interviewbit.com/embed/snippet/ffd2404eb144f68566b6"></iframe>

위 코드에서 핵심은 여기다.

```c++
 time12(time24); //1-arg constructor
```

클래스 간의 형변환을 **생성자를 이용하는 것**이다.

이는 상식적으로 간단한데, 다른 자료형을 받아서 내 입맛대로 커스텀 후 내 클래스에다 넣는다.

이것이 형변환의 목적이기 때문에 오버로딩 생성자를 이용하는 것이다.

이는 책에서는 **source** 쪽에서의 형변환이라고 표현하고 있다.

그럼 반대로, 반환 연산자를 이용하는 예제도 보자.

<iframe height="3000px" width="700px" src="https://www.interviewbit.com/embed/snippet/d8bb58aea7c152c76d96"></iframe>

이번엔 t24 쪽에서 반환 연산자를 통해서 t12로 반환해주고 있다.

그럼 이제 이런 질문이 나올 것이다.

---

## 그래서 둘 중 뭐가 더 좋은 건데??

하나씩 살펴보자.

우선 생성자를 이용한 형변환은 명시적으로 수행할 수 있으므로 코드의 **가독성이 높아진다.**

그러나 생성자를 통한 형변환은 새로운 객체를 생성하기 때문에 **시간적 손해**가 발생할 수 있다.

특히, **큰 객체의 경우 이러한 경향이 심해진다.**

반면에, **반환 연산자**를 이용한 형 변환은 객체 생성 단계를 거치지 않아도 된다.

이로 인해 **시간적 손해가 줄어든다.**

그러나 이쪽은 **명시적 변환이 불가능하므로, 의도치 않은 오류가 발생할 수 있다.**

따라서 필요한 용도에 맞게 잘 선택하면 된다!

---

<h2>📖 오늘의 핵심(다 알기 전까지는 넘어가지 말자❗)</h2>

✅ 1. 기본 연산자와 클래스 간의 형변환 방법을 안다.

✅ 2. 다른 클래스 간의 형변환 방법을 모두 알고, 그 특징을 안다.

⚠️ 묵시적 변환은 생각보다 큰 문제가 될 수 있다, 다음 시간엔 이를 해결하는 법을 배운다.

💣 과제, 없음

🔜 더 공부해보기,

<a href = "https://faculty.ksu.edu.sa/sites/default/files/ObjectOrientedProgramminginC4thEdition.pdf">읽어볼 거리(1) - 코드 전문</a>
