---
date: 2024-02-01 07:41:55
layout: post
title: "자료구조(19) - 집합과 해시 테이블"
subtitle: "해시 테이블을 통한 집합"
description: 해시 함수가 무엇인지 알고, 해시 테이블을 통한 집합의 ADT를 구현한다.
image: "https://res.cloudinary.com/dtloik0ts/image/upload/t_transformation/v1704821720/data_structure_yoppg7.png"
optimized_image: "https://res.cloudinary.com/dtloik0ts/image/upload/t_opt/v1704821720/data_structure_yoppg7.png"
category: 자료구조
tags:
  - 정리
  - 자료구조
author: Minsu Choi
paginate: false
---

<h2>🔚 짧게 하는 복습</h2>

✅ 1. 최소 스패닝 트리(Minimum Spanning Tree)의 뜻을 안다.

✅ 2. 크루스칼 알고리즘을 통해서 최소 스패닝 트리를 구할 수 있다.

✅ 3. 프림 알고리즘을 통해서 최소 스패닝 트리를 구할 수 있다.

혹시 기억이 안 난다면, <u><a href = "/자료구조(17)-유니온-파인드/"> 다시 돌아가자</a></u>

---

우리는 저번 시간까지 거의 모든 자료구조의 수업이 끝났다.

본인 학부 기준(경북대학교 컴공), 자료구조의 진도는 여기까지였다.

그런데 알고리즘을 공부하면서, 조금 커리큘럼에 아쉬움을 느껴 우리 자료구조 강의에서는 딱 2가지의 특별한 자료구조를 더 다루고자 한다.

이번 시간에 다룰 자료구조는 **집합(Set)**이다.

수학을 해본 적이 있다면, 또 우리가 이전에도 몇 번 읽어볼 거리나 서로소 집합을 통해 다룬 적 있기에 익숙할 것이다.

바로 집합의 정의와 ADT에 대해 알아보자.

---

## 집합(Set)이란?

**집합(Set)**이란 **순서, 중복 없이** 원소가 집합에 속하는지 아닌지만 판단하는 자료구조이다.

그렇기에 ADT도 원소의 **추가/제거/조회** 이 3가지만 다루면 된다.

대부분 자료구조에서 **검색/조회**를 다루었기 때문에, 사실 지금까지 배웠던 대부분 자료구조로 충분히 구현할 수 있다.

하지만 그중에서도, 검색에 최적화된 자료구조인 **이진 검색 트리(BST)**가 있었다.

그리고 BST에서도 원소의 **추가, 삭제, 조회** 모든 것이 가능했다. _(중복 추가는 무시하면 됨)_

하지만 BST는 사실 구조체 단위로 노드도 만들어야 하고, 트리의 구현이 쉬운 것이 아니기에 더 좋은 자료구조를 찾았다.

그렇게 눈을 돌린 것은 배열이었는데, 집합의 원소를 배열 인덱스를 통해 바로 접근할 수 있다면 좋으리라 생각한다.

즉 아래와 같은 구조면 된다는 뜻이다.

2, 3, 5 원소가 집합에 속한다면 1, 아니면 0으로 표현을 하면 된다.

```c
int set[6] = {0, 0, 1, 1, 0, 1};
```

그런데 이는 생각보다 쉽지 않은데 아래와 같은 문제가 있다.

1. 겨우 int 정수의 표현 범위만 해도 무려 21억이다. (21억 개 원소를 가진 배열을 선언하면, stack 메모리를 초과한다.)

2. 원소는 정수형 말고도 많은 자료형이 있을 수 있다.(문자열, 문자, 실수 등..)

하지만 컴퓨터 공학자들은 위 문제를 해결하는 혁신적인 방법을 만들어낸다.

그 방법인 **해시 함수**를 소개하겠다.

---

## 해시 함수란?

우선 수학에서 **함수**는 **어떤 집합을 다른 집합으로 매칭**시키는 개념이다.

예를 들어, y = 2x라는 함수는 {1, 2, 3, 4}라는 x 집합의 값을, {2, 4, 6, 8}이라는 y 집합의 값으로 바꿀 수 있다.

다른 함수인 y = x % 10은 x의 범위가 얼마나 크든 간에 0 ~ 9의 집합으로 매칭시킬 수 있다.

또한, y = x \* 100이라는 함수는 0.01보다 큰 모든 실수를 정수로 타입을 바꿔서 매칭할 수도 있다.

이게 왜 유의미하냐 하면, **어떤 특정 값을 다루기 쉬운 인덱스 값으로 바꿀 수 있기 때문이다.**

29174923은 배열의 인덱스로 쓰기 어렵지만, \%10을 취한 3은 훨씬 다루기 쉽다.

또, 0.37은 배열의 인덱스로 쓸 수 없지만, \*100을 취한 값인 37은 인덱스로 사용할 수 있다.

이렇게 원래의 값을 함수를 통해 특정한 값으로 바꾸는 작업을 **해싱**이라고 한다. 또, 그 함수는 **해시 함수**라고 한다.

원래 값을 **키**, 해시 함수를 통해 바뀐 값을 **해시값**이라고 한다.

대표적인 해시 함수는 위에서 언급한 % 연산을 이용하지만, 실제 사용되는 해시 함수는 훨씬 복잡한 수식을 사용한다.

또 이렇게 **해시 함수와 배열을 이용해서, 특정 값을 고유한 인덱스로 대응하여 데이터를 저장하는 자료 구조**를 **해시 테이블**라고 한다.

해시 테이블을 통해서 집합 ADT를 구현할 수 있다.

---

<h2>집합 ADT</h2>

<div style="border: 2px solid black; padding: 10px; margin: 10px; background-color: #f9f9f9; border-radius: 8px;">
  <li>자료 : 정수, {123456780, 123456781, 123456782, 123456783, 123456784, 123456785}를 {0, 1, 2, 3, 4, 5}로 매칭</li>
  <li>기능1 추가 : 집합에 원소를 추가한다</li>
  <li>기능2 삭제 : 집합에서 원소를 삭제한다</li>
  <li>기능3 조회 : 집합에 원소가 속한지 확인한다.</li>
</div>

역시나 ADT는 요구에 맞게 작성되는 것이기에, **절대적인 것이 아니라 필요에 맞게 수정할 수 있다.**

---

## 집합의 구현

아래 코드 예제를 보자.

```c
#include <stdio.h>
#define NODE 6

/*
자료 : 정수
{123456780, 123456781, 123456782, 123456783, 123456784, 123456785}를
{0, 1, 2, 3, 4, 5}로 매칭

기능1 추가 : 집합에 원소를 추가한다
기능2 삭제 : 집합에서 원소를 삭제한다
기능3 조회 : 집합에 원소가 속한지 확인한다
*/

// 해시 함수
int hash(const int value) {
	return value % 10;
}


//기능1 추가 : 집합에 원소를 추가한다
void insert(int set[], const int value) {
	int hashValue = hash(value);
	set[hashValue] = value;
	printf("%d is added to the set with %d by hash function\n\n", value, hashValue);
}


//기능2 삭제 : 집합에서 원소를 삭제한다
void delete(int set[], const int value) {
	int hashValue = hash(value);
	if (set[hashValue] == -1) {
		printf("%d is not in the set\n\n", value);
		return;
	}
	set[hashValue] = -1;
	printf("%d is deleted from the set\n\n", value);
}

//기능3 조회 : 집합에 원소가 속한지 확인한다
void search(int set[], const int value) {
	int hashValue = hash(value);
	if (set[hashValue] == -1) {
		printf("%d is not in the set\n\n", value);
	}
	else {
		printf("%d is in the set\n\n", value);
	}
}

int main(void) {
	int set[NODE] = { -1, -1, -1, -1, -1, -1 };
	// 매칭되는 원소가 없다면 -1로 해놓음

	insert(set, 123456780);
	insert(set, 123456781);
	insert(set, 123456782);
	insert(set, 123456783);
	insert(set, 123456784);
	insert(set, 123456785);

	delete(set, 123456781);
	delete(set, 123456783);
	delete(set, 123456785);

	search(set, 123456780);
	search(set, 123456781);
	search(set, 123456782);
	search(set, 123456783);
	search(set, 123456784);
	search(set, 123456785);

}
```

---

## 결과창

```js
123456780 is added to the set with 0 by hash function

123456781 is added to the set with 1 by hash function

123456782 is added to the set with 2 by hash function

123456783 is added to the set with 3 by hash function

123456784 is added to the set with 4 by hash function

123456785 is added to the set with 5 by hash function

123456781 is deleted from the set

123456783 is deleted from the set

123456785 is deleted from the set

123456780 is in the set

123456781 is not in the set

123456782 is in the set

123456783 is not in the set

123456784 is in the set

123456785 is not in the set
```

---

## 위 해시 테이블의 한계

사실 잘 따라왔다면, 위의 예시를 보며 의문을 가져야 한다.

왜냐하면, 이런 허점이 있기 때문이다.

만약 집합의 원소 범위가 123456780에서 123456785가 아니라, 123456780에서 123456790이라면??

알다시피 123456780과 123456790은 해시값이 같다.

이렇게 **두 다른 키가 같은 해시값을 가지는 경우**를 **충돌**이라고 한다.

또한, **충돌이 없는 이상적인 함수**를 **퍼펙트 해시 함수(perfect hash function)**이라고 한다.

하지만 퍼펙트 해시 함수는 특정한 경우 존재하고, 일반적으로는 없는 것으로 알려져 있다.

즉, 일반적인 상황에 대해서 **충돌**의 발생은 불가피하다.

그렇다면 어떻게 충돌을 해결할까?

두 가지 방법 **체이닝**과 **개방 주소법**을 통해 해결해보겠다.

---

## 체이닝(chaining)이란?

**체이닝**이란 **키를 저장하는 배열을 만드는 것이 아니라, 키들을 저장하는 연결리스트를 저장하는 배열**을 만드는 것이다.

이해가 잘 안 되겠지만 아래 그림을 보자.

<img src ="https://res.cloudinary.com/dtloik0ts/image/upload/v1706780573/%EC%B2%B4%EC%9D%B4%EB%8B%9D1_gmj9i5.png">

123456790의 해시값인 0 인덱스에는 이미 키가 저장되어있는 상태이다.

<img src = "https://res.cloudinary.com/dtloik0ts/image/upload/v1706780573/%EC%B2%B4%EC%9D%B4%EB%8B%9D2_bezgiw.png">

여기서 위 그림처럼 연결리스트를 통해 그 뒤에 추가로 붙이는 것이다.

체이닝을 통한 충돌 해결은 자세한 구현은 **과제**로 남기겠다.

이렇게 해시테이블의 크기가 고정되어있지 않은 경우, **동적 해시테이블**이라고 한다.

**장점은 얼마나 데이터가 들어오던지 충돌을 완벽하게 해결할 수 있다.**

**단점은 그만큼 동적할당을 통해 메모리 소모가 심해진다.**

---

## 개방 주소법(Open Addressing)이란?

**개방 주소법**이란 **충돌이 발생하면 키를 다른 빈 곳에 저장하는 방법**이다.

여기서 어떠한 규칙으로 다른 공간에 저장하느냐에 따라

1. 선형 탐사(Linear Probing)
2. 제곱 탐사(Quadratic Probing)
3. 이중 해싱(Double Hashing)
4. 무작위 탐사(Random Probing)

으로 나뉜다.

### 선형 탐사(Linear Probing)

만약 탐색 인덱스를 x<sub>0</sub>, x<sub>1</sub>, x<sub>2</sub>... 라고 하면, 아래와 같은 규칙을 가진다.

x<sub>i</sub> = (i + x<sub>0</sub>) % m (m은 배열의 마지막 인덱스)

쉽게 말하면, 처음 인덱스가 30인데 이미 차있다면 31, 32 ... 마지막 인덱스, 0, 1 ... 순서로 탐색 된다는 소리이다.

탐색하다가, 빈 곳을 찾으면 바로 그 인덱스에 키를 저장한다.

### 제곱 탐사(Quadratic Probing)

이중 탐사는 아래와 같은 식을 가진다.

x<sub>i</sub> = (x<sub>0</sub> + i * k<sub>1</sub> + i<sup>2</sup>*k<sub>2</sub>) % m (m은 배열의 마지막 인덱스, k<sub>1</sub>, k<sub>2</sub>는 임의의 상수)

선형 탐사보다는 충돌된 인덱스로부터 더 비규칙적으로 이동하기 때문에, 충돌의 확률이 적다.

하지만 엄연히 k<sub>1</sub>, k<sub>2</sub>의 값에 따라 성능이 달라진다.

만약 k<sub>1</sub>을 0, k<sub>2</sub>를 1이라고 하면 30, 31, 34, 39 .. 순서로 탐색한다는 의미이다.

### 이중 해시(Double Hashing)

이는 충돌이 발생 시, 아예 다른 해시 함수를 하나 더 이용해서 최종 해시값을 정하는 방식이다.

예를 들어, x<sub>i</sub> = (h<sub>0</sub> i\*h<sub>1</sub>) % m (m은 배열의 마지막 인덱스, h<sub>0</sub>, i\*h<sub>1</sub>는 각각 해시값)

### 무작위 탐사(Random Probing)

**무작위 탐사**는 앞의 탐사들과 달리 증가나 감소가 아니라, 다음 인덱스를 난수로 정하는 것이다.

이는 무작위라는 특성상 성능을 보장할 수 없는 것이 특징이다.

개방 주소법의 장점은 동적으로 할당되지 않기 때문에, 메모리가 절약된다는 점이다.

하지만 단점이 명확한데, **특정 영역에서 충돌이 많이 일어나고 키의 입력이 몰릴 수 있다.** 이를 **클러스터링**이라고 한다.

---

## 각 탐사 방법의 특징

또한, 각 탐사 방법은 아래의 특징을 가진다.

### 선형 탐사 (Linear Probing)

장점:

구현이 간단하며 메모리를 효율적으로 사용할 수 있다.

단점:

**1차 클러스터링(Primary Clustering)**이 발생할 수 있어, 충돌이 반복되면 성능이 저하될 수 있다.

데이터가 일부 영역에 몰려서 해시 테이블이 불균형해질 수 있다.

### 제곱 탐사(Quadratic Probing)

장점:

선형 탐사에서 발생하는 1차 클러스터링 문제를 해결한다.

충돌이 발생한 인덱스로부터 더 떨어져서 탐사하기 때문에 규칙적인 패턴이 줄어든다.

단점:

여전히 2차 **클러스터링(Secondary Clustering)** 문제가 발생할 수 있다.

선형 탐사보다는 연산이 복잡하게 된다.

### 이중 해싱(Double Hashing)

장점:

더 복잡한 해시 함수를 사용하기 때문에 클러스터링 문제를 줄일 수 있다.

두 번째 해시 함수가 충돌이 발생한 경우를 고려하기 때문에 무작위 탐사와 비슷한 성능을 가질 수 있다.

단점:

구현이 복잡하고 추가 계산이 필요하다.

나쁜 해시 함수나 나쁜 파라미터로 인해 성능이 감소할 수도 있다.

### 무작위 탐사(Random Probing)

장점:

완전히 무작위로 탐사하기 때문에 클러스터링의 발생 가능성이 작다.

다양한 상황에서 성능이 좋을 수 있다.

단점:

무작위성을 유지하기 위해 추가적인 난수 생성이 필요하므로 연산이 늘어날 수 있다.

구현이 복잡하며 일관된 성능을 보장하기 어려울 수 있다.

설명만 하고 넘어가긴 아쉬우니, 공개 주소법 중 **선형 탐사**와 **이중 해싱**만 직접 구현해보겠다. _(나머지는 과제로 넘기겠다.)_

---

## 선형 탐사(Linear Probing) 구현

```c
#include <stdio.h>
#define NODE 6

/*
자료 : 정수
{123456780, 123456781, 123456782, 123456783, 123456784, 123456785}를
{0, 1, 2, 3, 4, 5}로 매칭

기능1 추가 : 집합에 원소를 추가한다
기능2 삭제 : 집합에서 원소를 삭제한다
기능3 조회 : 집합에 원소가 속한지 확인한다
*/

// 해시 함수
int hash(const int value) {
	return value % 10;
}


//기능1 추가 : 집합에 원소를 추가한다
void insert(int set[], const int value) {
	int hashValue = hash(value);

	int probing_num = 0;
	// 전부 탐색했는데 없으면 무한루프가 돌게되니

	while(set[hashValue] != -1 && probing_num<NODE) {
		hashValue += 1;
		probing_num += 1;
		// 선형 탐사, 탐사수 기록

		if (hashValue == NODE) {
			hashValue = 0;
		}

		//최대 인덱스가 넘어가면 0부터 다시 시작
	}

	if (probing_num == NODE) {
		printf("Hash table is full!\n\n");
		return;
	}

	set[hashValue] = value;
	printf("%d is added to the set with %d by hash function\n\n", value, hashValue);
}


//기능2 삭제 : 집합에서 원소를 삭제한다
void delete(int set[], const int value) {
	int hashValue = hash(value);
	int probing_num = 0;
	while(set[hashValue] != value && probing_num < NODE) {
		hashValue += 1;
		probing_num += 1;
		// 선형 탐사, 탐사수 기록

		if (hashValue == NODE) {
			hashValue = 0;
		}

		//최대 인덱스가 넘어가면 0부터 다시 시작
	}
	// 루프를 나왔는데 값이 아니면 없는 것이고, 값이면 삭제한다.

	if (set[hashValue] == value) {
		set[hashValue] = -1;
		printf("%d is deleted from the set\n\n", value);
		return;
	}
	else {
		printf("%d is not in the set\n\n", value);
		return;
	}

}

//기능3 조회 : 집합에 원소가 속한지 확인한다
void search(int set[], const int value) {
	int hashValue = hash(value);

	int probing_num = 0;
	while (set[hashValue] != value && probing_num < NODE) {
		hashValue += 1;
		probing_num += 1;
		// 선형 탐사, 탐사수 기록

		if (hashValue == NODE) {
			hashValue = 0;
		}

		//최대 인덱스가 넘어가면 0부터 다시 시작
	}
	// 루프를 나왔는데 값이 아니면 없는 것이고, 값이면 있는 것임.

	if (set[hashValue] == value) {
		printf("%d is in the set\n\n", value);
	}
	else {
		printf("%d is not in the set\n\n", value);
	}
}

int main(void) {
	int set[NODE] = { -1, -1, -1, -1, -1, -1 };
	// 매칭되는 원소가 없다면 -1로 해놓음

	insert(set, 123456780);
	insert(set, 123456781);
	insert(set, 123456782);
	insert(set, 123456783);
	insert(set, 123456784);
	insert(set, 123456790);//충돌 일으킴
	insert(set, 123456785);

	delete(set, 123456781);
	delete(set, 123456783);
	delete(set, 123456785);

	search(set, 123456780);
	search(set, 123456781);
	search(set, 123456782);
	search(set, 123456783);
	search(set, 123456784);
	search(set, 123456790);
	search(set, 123456785);

}
```

---

## 결과창

```js
123456780 is added to the set with 0 by hash function

123456781 is added to the set with 1 by hash function

123456782 is added to the set with 2 by hash function

123456783 is added to the set with 3 by hash function

123456784 is added to the set with 4 by hash function

123456790 is added to the set with 5 by hash function

Hash table is full!

123456781 is deleted from the set

123456783 is deleted from the set

123456785 is not in the set

123456780 is in the set

123456781 is not in the set

123456782 is in the set

123456783 is not in the set

123456784 is in the set

123456790 is in the set

123456785 is not in the set
```

---

## 이중 해싱(Double Hashing) 구현

```c
#include <stdio.h>
#define NODE 6

/*
자료 : 정수
{123456780, 123456781, 123456782, 123456783, 123456784, 123456785}를
{0, 1, 2, 3, 4, 5}로 매칭

기능1 추가 : 집합에 원소를 추가한다
기능2 삭제 : 집합에서 원소를 삭제한다
기능3 조회 : 집합에 원소가 속한지 확인한다
*/

int hash1(const int value) {
	return value * 3;
}

int hash2(const int value) {
	return value * 17;
}

// 해시 함수
int hash(const int value, int i) {
	return (hash1(value) + i * hash2(value)) % 5;
}
// 해시값 2개를 써서 해싱을 한다.


//기능1 추가 : 집합에 원소를 추가한다
void insert(int set[], const int value) {
	int probing_num = 0;
	int hashValue = hash(value, probing_num);
	// 탐사 횟수를 전달해서 충돌을 관리한다.
	// 전부 탐색했는데 없으면 무한루프가 돌게되니

	while(set[hashValue] != -1 && probing_num<NODE) {
		hashValue += 1;
		probing_num += 1;
		// 선형 탐사, 탐사수 기록

		if (hashValue == NODE) {
			hashValue = 0;
		}

		//최대 인덱스가 넘어가면 0부터 다시 시작
	}

	if (probing_num == NODE) {
		printf("Hash table is full!\n\n");
		return;
	}

	set[hashValue] = value;
	printf("Collison occured for %d times\n\n", probing_num);
	// 충돌을 보기 힘드니, 충돌 횟수를 시각화

	printf("%d is added to the set with %d by hash function\n\n", value, hashValue);
}


//기능2 삭제 : 집합에서 원소를 삭제한다
void delete(int set[], const int value) {
	int probing_num = 0;
	int hashValue = hash(value, probing_num);

	while(set[hashValue] != value && probing_num < NODE) {
		hashValue += 1;
		probing_num += 1;
		// 선형 탐사, 탐사수 기록

		if (hashValue == NODE) {
			hashValue = 0;
		}

		//최대 인덱스가 넘어가면 0부터 다시 시작
	}

	if (set[hashValue] == value) {
		set[hashValue] = -1;
		printf("%d is deleted from the set\n\n", value);
		return;
	}
	else {
		printf("%d is not in the set\n\n", value);
		return;
	}

}

//기능3 조회 : 집합에 원소가 속한지 확인한다
void search(int set[], const int value) {
	int probing_num = 0;
	int hashValue = hash(value, probing_num);

	while (set[hashValue] != value && probing_num < NODE) {
		hashValue += 1;
		probing_num += 1;
		// 선형 탐사, 탐사수 기록

		if (hashValue == NODE) {
			hashValue = 0;
		}

		//최대 인덱스가 넘어가면 0부터 다시 시작
	}

	if (set[hashValue] == value) {
		printf("%d is in the set\n\n", value);
	}
	else {
		printf("%d is not in the set\n\n", value);
	}
}

int main(void) {
	int set[NODE] = { -1, -1, -1, -1, -1, -1 };
	// 매칭되는 원소가 없다면 -1로 해놓음

	insert(set, 123456780);
	insert(set, 123456781);
	insert(set, 123456782);
	insert(set, 123456783);
	insert(set, 123456784);
	insert(set, 123456790);
	insert(set, 123456785);

	delete(set, 123456781);
	delete(set, 123456783);
	delete(set, 123456785);

	search(set, 123456780);
	search(set, 123456781);
	search(set, 123456782);
	search(set, 123456783);
	search(set, 123456784);
	search(set, 123456790);
	search(set, 123456785);

}
```

---

## 결과창

```js
Collison occured for 0 times

123456780 is added to the set with 0 by hash function

Collison occured for 0 times

123456781 is added to the set with 3 by hash function

Collison occured for 0 times

123456782 is added to the set with 1 by hash function

Collison occured for 0 times

123456783 is added to the set with 4 by hash function

Collison occured for 0 times

123456784 is added to the set with 2 by hash function

Collison occured for 5 times

123456790 is added to the set with 5 by hash function

Hash table is full!

123456781 is deleted from the set

123456783 is deleted from the set

123456785 is not in the set

123456780 is in the set

123456781 is not in the set

123456782 is in the set

123456783 is not in the set

123456784 is in the set

123456790 is in the set

123456785 is not in the set
```

---

✅ 1. 해싱과 해시 함수를 안다.

✅ 2. 해시 테이블을 만들 수 있다.

✅ 3. 충돌이 무엇인지 알고, 체이닝과 공개 주소법을 통해서 충돌을 해결할 수 있다.

✅ 4. 종합적인 해시 테이블을 통해, 집합 ADT를 구현할 수 있다.

⚠️ 퍼펙트 해시 함수는 일반적으로 존재하지 않는다.

⚠️ 해시 함수와 탐사법은 성능에 지대한 영향을 준다. 신중히 결정해야 함.

💣 과제,

1. 인접 리스트를 통해서 체이닝을 구현하여 충돌을 관리한다.(난이도 中)

2. 제곱 탐사를 구현하여 충돌을 관리한다.(난이도 中)

3. 무작위 탐사를 구현하여 충돌을 관리한다.(난이도 中) - random 라이브러리 이용

🔜 더 공부해보기,

1. <a href ="https://www.codestates.com/blog/content/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%ED%95%B4%EC%8B%9C%ED%95%A8%EC%88%98">읽어볼 거리(1) - 블록체인에도 쓰이는 해시 함수</a>
