---
date: 2024-01-16 15:26:04
layout: post
title: "자료구조(7) - 연결리스트"
subtitle: "연결리스트와 양방향 연결리스트의 ADT를 만들고, 구현"
description: 연결리스트와 양방향 연결리스트에서 끝 삽입, 중간 삽입, 제거, 수정, 참조를 구현한다.
image: "https://res.cloudinary.com/dtloik0ts/image/upload/t_transformation/v1704821720/data_structure_yoppg7.png"
optimized_image: "https://res.cloudinary.com/dtloik0ts/image/upload/t_opt/v1704821720/data_structure_yoppg7.png"
category: 자료구조
tags:
  - 정리
  - 자료구조
author: Minsu Choi
paginate: false
---

<h2>🔚 짧게 하는 복습</h2>

✅ 1. 정적 배열로 큐와 주어진 ADT를 구현할 수 있다.

✅ 2. 동적 배열로 큐와 주어진 ADT를 구현할 수 있다.

✅ 3. 정적 배열로 환형 큐와 주어진 ADT를 구현할 수 있다.

혹시 기억이 안 난다면, <u><a href = "/자료구조(6)-큐,-환형-큐/"> 다시 돌아가자</a></u>

---

이번 강의는 마지막 **선형 자료구조**인 **연결 리스트**에 대해 다루어보겠다.

이 때까지의 선형구조는 정적 배열 혹은 동적 배열, 즉 배열을 기반으로 자료구조를 구현했다.

그런데 연결리스트는, **구조체와 구조체 포인터**를 기반으로 하여, **서로를 가리켜서 마치 배열처럼 구현된** 특별한 선형 자료구조이다.

그리고 이 특별한 구조는 **트리**라는 자료 구조로 확장되기 때문에, 꼭 잘 이해해야한다.

연결리스트의 구조체는 보통 이렇게 만들어진다.

```c
typedef struct Node* nodePointer;

typedef struct Node {
	int data;               // 자료 값
	nodePointer next;       // 다음 노드를 가리키는 포인터
} node;                      // 노드

```

저 구조체 한 단위를 노드라고 하고, 한 노드안의 포인터(**노드 포인터**)는 다른 노드를 가리키게 된다.

처음 아무 자료가 없이 연결리스트의 시작을 담당하는 **노드 포인터**를 **헤드**라고 한다.

보통 헤드에서 시작해서 계속 간접 참조를 하여 특정 위치까지 이동한다.

연결리스트와 배열의 가장 큰 차이는, **인덱스의 사용 유무**이다.

배열은 인덱스를 이용하면 직접 참조할 수 있지만, 연결리스트는 헤드에서 시작해서 포인터를 이용해서 접근해야 하기 때문에 느리다.

이러한 이유로 연결리스트는 보통 인덱스를 사용하지 않는다.(**처음 혹은 끝에 접근해서 추가, 삭제** 혹은 **값을 찾아서 삭제**)

---

<h2>연결리스트 ADT</h2>

<div style="border: 2px solid black; padding: 10px; margin: 10px; background-color: #f9f9f9; border-radius: 8px;">
  <li>자료 : 정수</li>
  <li>기능1 끝 삽입 : 원소를 연결리스트의 끝에 입력한다.</li>
  <li>기능2 처음 삽입 : 원소를 연결리스트의 처음에 입력한다.</li>
  <li>기능3 끝 삭제 : 연결리스트의 마지막 값을 삭제한다.</li>
  <li>기능4 처음 삭제 : 연결리스트의 처음 값을 삭제한다.</li>
  <li>기능5 값 삭제 : 원소를 입력받아, 그 값이 있다면 값을 삭제한다.</li>
  <li>기능6 수정 : 원소를 입력받아, 그 값이 있다면 기존의 값을 입력받은 값으로 수정한다.</li>
  <li>기능7 순회 : 연결리스트의 모든 원소를 처음부터 출력한다.</li>
</div>

역시나 ADT는 요구에 맞게 작성되는 것이기에, **절대적인 것이 아니라 필요에 맞게 수정이 가능하다.**

---

## 연결리스트 구현

```c
#include <stdio.h>
#include <stdlib.h>

/*
자료 : 정수
기능1 끝 삽입 : 원소를 연결리스트의 끝에 입력한다.
기능2 처음 삽입 : 원소를 연결리스트의 처음에 입력한다.
기능3 끝 삭제 : 연결리스트의 마지막 값을 삭제한다.
기능4 처음 삭제 : 연결리스트의 처음 값을 삭제한다.
기능5 값 삭제 : 원소를 입력받아, 그 값이 있다면 값을 삭제한다.
기능6 수정 : 원소를 입력받아, 그 값이 있다면 기존의 값을 입력받은 값으로 수정한다.
기능7 순회 : 연결리스트의 모든 원소를 처음부터 출력한다.
*/

typedef struct Node* nodePointer;

typedef struct Node {
	int data;               // 자료 값
	nodePointer next;       // 다음 노드를 가리키는 포인터
} node;                      // 노드


// + 노드를 만드는 함수
nodePointer make_node(int data) {
	nodePointer new_node = (nodePointer)malloc(sizeof(node));
	new_node->data = data;
	new_node->next = NULL;

	return new_node;
}

// 노드가 비었는지 확인하는 함수

int is_empty(nodePointer head) {
	if (head == NULL) {
		return 1; // 비었다면 참
	}
	else {
		return 0; // 아니라면 거짓
	}
}

//기능1 끝 삽입 : 원소를 연결리스트의 끝에 입력한다.
int push_back(nodePointer* head, int data) {
	if (is_empty(*head)) {
		*head = make_node(data);
	}
	else {
		nodePointer temp = *head;//편하게 하기 위해 temp 변수 생성
		while (temp->next != NULL) { //다음 노드포인터 값이 NULL일 때까지
			temp = temp->next;
		}
		temp->next = make_node(data);//맨 마지막에 추가
	}
	printf("sucessfully pushed %d in the back of linked list\n\n", data);
	return 0;
}

//기능2 처음 삽입 : 원소를 연결리스트의 처음에 입력한다.
int push_front(nodePointer* head, int data) {
	if (is_empty(*head)) {
		*head = make_node(data);
	}
	else {
		nodePointer temp = *head; //만약 헤드가 가리키던 노드가 있다면, temp에 주소 저장
		nodePointer new_node = make_node(data);
		*head = new_node; //헤드는 새 노드를 가리키고,
		new_node->next = temp;// 새 노드는 헤드가 가리키던 노드를 연결
	}
	printf("sucessfully pushed %d in the front of linked list\n\n", data);
	return 0;
}

//기능3 끝 삭제 : 연결리스트의 마지막 값을 삭제한다.
int del_back(nodePointer* head) {
	if (is_empty(*head)) {
		printf("Linked list has no element!\n\n");//비었으면 에러
		return -1;
	}
	else {
		nodePointer temp = *head;
		nodePointer prev = NULL; // 마지막 노드포인터 직전의 노드포인터를 알아야, next에 NULL처리를 해줄 수 있음.
		while (temp->next != NULL) { //다음 노드포인터 값이 NULL일 때까지
			prev = temp;
			temp = temp->next;
		}
		prev->next = NULL;
		free(temp);
	}
	printf("sucessfully deleted in the back of linked list\n\n");
	return 0;
}

//기능4 처음 삭제 : 연결리스트의 처음 값을 삭제한다.
int del_front(nodePointer* head) {
	if (is_empty(*head)) {
		printf("Linked list has no element!\n\n");//비었으면 에러
        return -1;
	}
	else {
		nodePointer temp = *head; //만약 헤드가 가리키던 노드가 있다면, temp에 주소 저장
		*head = temp->next; // 헤드가 가리키던 노드(temp)의 다음 노드를 가리키게 함.
		free(temp);
	}
	printf("sucessfully deleted in the front of linked list\n\n");
	return 0;
}

//기능5 값 삭제 : 원소를 입력받아, 그 값이 있다면 값을 삭제한다.
int del_value(nodePointer* head, int data) {
	if (is_empty(*head)) {
		printf("Linked list has no element!\n\n");//비었으면 에러
		return -1;
	}
	else {
		nodePointer temp = *head;
		nodePointer prev = NULL; // 특정 값 노드포인터 직전의 노드포인터를 알아야, next에 NULL처리를 해줄 수 있음.
		while (temp->next != NULL) { //다음 노드포인터 값이 NULL일 때까지
			if (temp->data == data) {
				prev->next = temp->next; //
				free(temp);
				printf("sucessfully %d is deleted in the front of linked list\n\n", data);
				return 0;
			}
			prev = temp;
			temp = temp->next;
		}
	}
	printf("There is no %d in linked list\n\n", data);
	return -1;
}

//기능6 수정 : 원소를 입력받아, 그 값이 있다면 기존의 값을 입력받은 값으로 수정한다.
int update(nodePointer* head, int data, int new_data) {
	if (is_empty(*head)) {
		printf("Linked list has no element!\n\n");//비었으면 에러
		return -1;
	}
	else {
		nodePointer temp = *head;
		nodePointer prev = NULL; // 특정 값 노드포인터 직전의 노드포인터를 알아야, next에 NULL처리를 해줄 수 있음.
		while (temp->next != NULL) { //다음 노드포인터 값이 NULL일 때까지
			if (temp->data == data) {
				temp->data = new_data;
				printf("sucessfully %d is deleted in the front of linked list\n\n", data);
				return 0;
			}
			prev = temp;
			temp = temp->next;
		}
	}
	printf("There is no %d in linked list\n\n", data);
	return -1;
}


//기능7 순회 : 연결리스트의 모든 원소를 처음부터 출력한다.
int traversal(nodePointer head) {
	if (is_empty(head)) {
		printf("Linked list has no element!\n\n");//비었으면 에러
		return -1;
	}
	else {
		printf("traversal:\n");
		nodePointer temp = head;
		while (temp != NULL) {//현재 포인터 값이 NULL일 때까지
			printf("%d ", temp->data);
			temp = temp->next;
		}
		printf("\n\n");
	}
	return 0;
}


int main(void) {
	nodePointer head = NULL;// 시작 노드
	traversal(head);

	push_back(&head, 1);
	push_back(&head, 2);
	push_back(&head, 3);

	traversal(head); // 1 2 3

	push_front(&head, 1);
	push_front(&head, 2);
	push_front(&head, 3);

	traversal(head); // 3 2 1 1 2 3

	del_front(&head);
	del_back(&head);

	traversal(head); // 2 1 1 2


	push_front(&head, 7);
	push_front(&head, 6);
	push_front(&head, 4);
	push_back(&head, 5);

	traversal(head); // 4 6 7 2 1 1 2 5

	del_value(&head, 6);
	del_value(&head, 8); //에러

	traversal(head); // 4 7 2 1 1 2 5

	update(&head, 7, 3);
	update(&head, 7, 3);//에러

	traversal(head); // 4 3 2 1 1 2 5
}
```

연결리스트 뿐만 아니라, 자료구조를 공부할 때는 그림을 잘 상상하는 것이 중요하다.

할당과 해제 시, 어떤 구조를 가지는 지 잘 생각해봐야 하는데 각각의 상황은 마치 이렇다.

검은 색 실선은 실제로 가리키는 것, 초록색 점선은 포인터의 더 이상 가리키지 않는 주소이다.

또한, **초록색 점선**이 노드를 가리키고 있다면 **할당 해제**를 의미한다.

### 빈 연결리스트에 연결하는 경우

<ol>
<li>head가 아무 것도 가리키지 않고있다.(NULL)</li>
<img src ="https://res.cloudinary.com/dtloik0ts/image/upload/v1705424468/INSERT_TO_EMPTY_uaccpd.png">
<li>새로 노드를 할당하고, head가 새 노드를 가리키게 한다.</li>
<img src = "https://res.cloudinary.com/dtloik0ts/image/upload/v1705424965/INSERT_TO_EMPTY2_dv5sqt.png">
</ol>

### 원소가 한 개 이상 있는 연결리스트의 마지막에 연결하는 경우

<ol>
<li>마지막 노드의 노드포인터가 아무 것도 가리키지 않고있다.(NULL)</li>
<img src ="https://res.cloudinary.com/dtloik0ts/image/upload/v1705424964/%EB%81%9D_%EC%82%BD%EC%9E%85_1_piiixp.png">
<li>새로 노드를 할당하고, 마지막 노드의 노드포인터가 새 노드를 가리키게 한다.</li>
<img src = "https://res.cloudinary.com/dtloik0ts/image/upload/v1705424964/%EB%81%9D_%EC%82%BD%EC%9E%852_ahrwfa.png">
</ol>

### 원소가 한 개 이상 있는 연결리스트의 처음에 연결하는 경우

<ol>
<li>head가 다음 노드를 가리키고 있다.</li>
<img src ="https://res.cloudinary.com/dtloik0ts/image/upload/v1705425306/%EC%B2%98%EC%9D%8C_%EC%82%BD%EC%9E%85_1_xr6gvi.png">
<li>새로 노드를 할당하고, head가 원래 가리키던 노드 말고 새 노드를 가리킨다.</li>
<li>새 노드가 원래 head가 가리키던 노드를 가리킨다.</li>
<img src = "https://res.cloudinary.com/dtloik0ts/image/upload/v1705425306/%EC%B2%98%EC%9D%8C_%EC%82%BD%EC%9E%85_2_lt092f.png">
</ol>

### 원소가 한 개 이상 있는 연결리스트의 마지막 원소를 삭제하는 경우

<ol>
<li>마지막 노드의 노드포인터가 아무 것도 가리키지 않고있다.(NULL)</li>
<img src ="https://res.cloudinary.com/dtloik0ts/image/upload/v1705425306/%EC%B2%98%EC%9D%8C_%EC%82%BD%EC%9E%85_1_xr6gvi.png">
<li>마지막 노드의 바로 전 노드의 노드포인터를 아무 것도 가리키지 않게한다.(NULL)</li>
<li>마지막 노드를 할당 해제한다.</li>
<img src = "https://res.cloudinary.com/dtloik0ts/image/upload/v1705426195/%EB%A7%88%EC%A7%80%EB%A7%89_%EC%82%AD%EC%A0%9C_fkq6pg.png">
</ol>

### 원소가 한 개 이상 있는 연결리스트의 처음 원소를 삭제하는 경우

<ol>
<li>head가 처음 노드를 가리키고 있다.</li>
<img src ="https://res.cloudinary.com/dtloik0ts/image/upload/v1705425306/%EC%B2%98%EC%9D%8C_%EC%82%BD%EC%9E%85_1_xr6gvi.png">
<li>head가 원래 가리키던 처음 노드 말고, 그 노드가 가리키던 다음 주소를 가리킨다.</li>
<li>처음 노드를 할당 해제한다.</li>
<img src = "https://res.cloudinary.com/dtloik0ts/image/upload/v1705425896/%EC%B2%98%EC%9D%8C_%EC%82%AD%EC%A0%9C_nebpol.png">
</ol>

### 원소가 한 개 이상 있는 연결리스트의 중간 원소를 삭제하는 경우

가장 복잡하기 때문에, 과제로 넘기도록 하겠다!

---

## 결과창

```js
Linked list has no element!

sucessfully pushed 1 in the back of linked list

sucessfully pushed 2 in the back of linked list

sucessfully pushed 3 in the back of linked list

traversal:
1 2 3

sucessfully pushed 1 in the front of linked list

sucessfully pushed 2 in the front of linked list

sucessfully pushed 3 in the front of linked list

traversal:
3 2 1 1 2 3

sucessfully deleted in the front of linked list

sucessfully deleted in the back of linked list

traversal:
2 1 1 2

sucessfully pushed 7 in the front of linked list

sucessfully pushed 6 in the front of linked list

sucessfully pushed 4 in the front of linked list

sucessfully pushed 5 in the back of linked list

traversal:
4 6 7 2 1 1 2 5

sucessfully 6 is deleted in the front of linked list

There is no 8 in linked list

traversal:
4 7 2 1 1 2 5

sucessfully 7 is deleted in the front of linked list

There is no 7 in linked list

traversal:
4 3 2 1 1 2 5
```

---
