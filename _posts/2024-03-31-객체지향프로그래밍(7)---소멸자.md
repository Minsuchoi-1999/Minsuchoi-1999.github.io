---
date: 2024-03-31 07:51:24
layout: post
title: "객체지향프로그래밍(7) - 소멸자"
subtitle: "메모리 구조를 통한 소멸자 이해"
description: 메모리 구조를 알고, 그를 통해 소멸자에 대해 안다.
image: https://res.cloudinary.com/dtloik0ts/image/upload/v1710305020/62209a189cc9185b70db045b_6ea4ua9rZnloCziXgO4TM7Zqa5oWwYrMD4Lc5BqWGYHrJreJ0-Cq-VTOChRhm1IEhqCGeGpQh9M8L516rerUQF9l1FnfQaHEFyTzex7ily50AmFoRns3jMWLyd5edWCJqBbqGzvo_xaa8bg.jpg
optimized_image: https://res.cloudinary.com/dtloik0ts/image/upload/t_opt/v1710305020/62209a189cc9185b70db045b_6ea4ua9rZnloCziXgO4TM7Zqa5oWwYrMD4Lc5BqWGYHrJreJ0-Cq-VTOChRhm1IEhqCGeGpQh9M8L516rerUQF9l1FnfQaHEFyTzex7ily50AmFoRns3jMWLyd5edWCJqBbqGzvo_xaa8bg.jpg
category: 객체지향프로그래밍
tags:
  - 정리
  - 객체지향프로그래밍
author: Minsu Choi
paginate: false
---

<h2>🔚 짧게 하는 복습</h2>

✅ 1. 오버로딩이 무엇인지 알고, 장단점이 무엇인지 안다.

✅ 2. 생성자 오버로딩, 생성자 리스트를 사용할 줄 안다.

✅ 3. *<a href = "https://modoocode.com/173">읽어볼 거리</a>*를 통해, 오버로딩의 우선 순위를 이해한다.

혹시 기억이 안 난다면, <u><a href = "/객체지향프로그래밍(6)-함수-오버로딩/"> 다시 돌아가자</a></u>

---

저번 시간에는 함수 오버로딩을 통해 생성자에 대한 심화내용을 다루는 것을 했다.

**생성자**란 **객체 생성 시 호출되어 초기화를 하는 메소드**였다.

이번 시간에는 생성자의 반대 격인 **소멸자**에 대해 다루어보겠다.

---

## 소멸자란?

생성자와 소멸자는 굉장히 비슷한 형태를 가진다.

생성자처럼 **반환형이 없고**, **클래스 이름 앞**에 **~**를 붙여주면 그 자체가 소멸자 함수 선언이 된다.

생성자와 반대로, **소멸자**는 **객체의 수명이 끝날 때 호출되는 함수**이다.

여기서 잠깐, 객체의 수명이 뭐지…? 기억이 안 날 법하니 다시 설명해보겠다.

---

## 메모리 구조로 보는 변수의 할당 원리, 그에 따른 수명

간단한 복기를 하자면, 메모리 구조는 **Data, Text, Stack, Heap**, 총 4가지의 영역을 가진다.

<img src = "https://res.cloudinary.com/dtloik0ts/image/upload/v1703942913/image_oc40zn.png">

**텍스트 영역**이란 우리가 작성한 **코드**와 **상수**가 위치하며, 이 영역은 읽기 전용이어서 실행 중에 코드를 수정할 수 없다.**(함수도 여기 저장된다.)**

**데이터 영역**은 보통 **전역 변수**가 저장되고, **힙 영역**은 **동적 할당된 변수**가 저장된다.

**스택 영역**은 **함수 호출과 관련된 변수, 함수의 인자, 반환 주소** 등이 저장되는 영역이다.

즉, **객체**도 **구조체의 연장**이고 **하나의 변수**이니 **힙**, **스택** 또는 **데이터 영역**에 저장이 된다.

그렇다면 각 영역에서 변수가 얼마나 생존 가능한지를 생각해보면 된다.

가장 쉬운 것은 **데이터 영역**이다. 전역이니까 프로그램이 끝날 때, 객체도 같이 사라진다.

두 번째는 **힙 영역**이다. 당연히 동적 할당 되었는 변수이니, 할당이 해제될 때 객체는 사라진다.

마지막으로 **스택 영역**이 헷갈릴 수 있는데, 모든 프로그램은 기본적으로 함수를 호출하는 방식으로 진행된다. _(main 함수가 필수인 이유이다.)_

새 함수가 호출될 때마다 **스택 영역**에, 새 함수 **스택 프레임이 쌓인다.**

그 **함수가 실행되는 동안**에, 함수 내의 모든 변수는 **스택 프레임에서 실행**된다.

마지막으로 함수가 종료되면, **스택 프레임이 스택 영역에서 사라진다.**

**즉, 함수가 종료될 때 함수에서 호출한 객체도 같이 사라지는 것이다.** _(더 자세한 원리는 읽어볼 거리 참고)_

그렇다면 이제 직접 실습을 해보자.

---

## 실습 코드

<iframe height= "1500px" width= "700px" src="https://www.interviewbit.com/embed/snippet/f8886d6f5d31cefe6cc3"></iframe>

---

✅ 1. 메모리 구조에 대해 알고, 영역별 특징을 안다.

✅ 2. 영역별 변수의 수명을 이해한다.

✅ 3. 소멸자에 대해 안다.

💣 과제, 없음

1. <a href = "/c-언어(19)-함수-호출의-원리/">읽어볼 거리(1) - 함수 호출의 원리</a>
2. <a href = "/자료구조(3)-동적-할당과-원리/">읽어볼 거리(2) - 변수 저장 및 동적 할당의 원리</a>
