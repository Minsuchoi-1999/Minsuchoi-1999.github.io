---
date: 2024-03-14 06:51:10
layout: post
title: "객체지향프로그래밍(4) - 캡슐화, 추상화"
subtitle: "객체지향프로그래밍(OOP)의 성질인 캡슐화, 추상화 이해"
description: 객체지향프로그래밍(OOP)의 4대 성질 중 캡슐화와 추상화를 이해한다.
image: https://res.cloudinary.com/dtloik0ts/image/upload/v1710305020/62209a189cc9185b70db045b_6ea4ua9rZnloCziXgO4TM7Zqa5oWwYrMD4Lc5BqWGYHrJreJ0-Cq-VTOChRhm1IEhqCGeGpQh9M8L516rerUQF9l1FnfQaHEFyTzex7ily50AmFoRns3jMWLyd5edWCJqBbqGzvo_xaa8bg.jpg
optimized_image: https://res.cloudinary.com/dtloik0ts/image/upload/t_opt/v1710305020/62209a189cc9185b70db045b_6ea4ua9rZnloCziXgO4TM7Zqa5oWwYrMD4Lc5BqWGYHrJreJ0-Cq-VTOChRhm1IEhqCGeGpQh9M8L516rerUQF9l1FnfQaHEFyTzex7ily50AmFoRns3jMWLyd5edWCJqBbqGzvo_xaa8bg.jpg
category: 객체지향프로그래밍
tags:
  - 정리
  - 객체지향프로그래밍
author: Minsu Choi
paginate: false
---

<h2>🔚 짧게 하는 복습</h2>

✅ 1. 객체가 무엇인지 안다.

✅ 2. 클래스와 구조체가 무엇이 다른지 안다.

✅ 3. 클래스와 인스턴스에 대해 안다.

✅ 4. public과 private 속성에 대해 안다.

혹시 기억이 안 난다면, <u><a href = "/객체지향프로그래밍(3)-객체,-클래스,-인스턴스/"> 다시 돌아가자</a></u>

---

저번 강의까지 클래스와 인스턴스에 대한 개념을 배웠다.

**데이터와 기능을 함께 묶어 놓은 사용자 정의 데이터 형식**을 **클래스(Class)**, 그 **클래스를 통해 만들어진 실제 객체**를 **인스턴스(Instance)**라는 것을 배웠다.

그리고 우리가 흔히 말하는 **객체**는 **인스턴스와 같은 말이라는 것**까지 배웠다.

이번 강의는 조금 지루할 수 있는 이론 수업이 있겠다.

객체지향 프로그래밍의 4대 성질 중 **캡슐화**와 **추상화**에 대해 다루어보겠다.

---

## 캡슐화란?

**캡슐화**는 **클래스 내 맴버 변수와 메소드를 하나로 묶고, 실제 구현 내용을 내부에 감추어 은닉하는 것**을 숨기는 것을 말한다.

"실제 구현내용을 모르는데 어떻게 씁니까?"라고 질문이 들어올 수 있는데, 어떤 동작이 있는지만 안다면 구현내용과 무관하게 작성할 수 있다.

아래의 예를 보자.

<iframe height="375px" width="700px" src="https://www.interviewbit.com/embed/snippet/f3faa8cd7591f5acb360"></iframe>

우리가 새로운 자료형이라고 말했던 std::string은 사실 **메소드가 포함된 클래스**이다.

이 std::string를 사용하는데 내부에 어떻게 설계되어있는지 우리는 알 수 없다. **(필자도 알 수 없다.)**

하지만 길이를 반환해주는 메소드가 length(), 첫 문자를 반환해주는 메소드가 front(), 마지막 문자를 반환해주는 메소드가 back()이라는 메소드인 것을 안다면, 클래스에 대해 전혀 알지 못해도 사용하는 데 문제가 없는 것이다.

즉 캡슐화는 사용자가 필요한 부분만 노출하고, 알 필요가 없는 부분을 숨기는 것이다.

이러한 특징이 가지는 장점으로는 **보안 강화, 유지보수 용이, 모듈화로 인한 재사용성**이 있다.

1. **보안 강화** : 클래스의 접근 제어를 통해 민감한 정보에 대한 외부 접근을 막을 수 있다.

2. **유지보수 용이** : 객체의 내부 구현과 무관하게 외부에서는 객체의 메소드만 호출하기에, 내부 구현이 바뀌어도 전체 코드를 바꿔야 하는 일은 일어나지 않는다.

3. **모듈화와 재사용성** : **모듈**이란 **특수한 동작을 하는 코드 단위**로 대표적인 것으로는 **함수**와 **클래스**가 있다. 클래스 자체가 모듈이 되기 때문에 다른 부분에서 쉽게 재사용될 수 있다.

---

## 추상화란?

다음으로 **추상화**란 **현실 세계의 무엇을 단순화하여 클래스로 모델링하는 과정**을 말한다.

예를 들어, 우리가 만든 포켓몬 프로그램의 경우에

```c++
class pokemon {
private :
    // pokemon 클래스의 private 변수
	std::string name;
	int type;
	double hp;
	int defend;
	int mobility;
	struct skill_info skill;

    // pokemon 클래스의 private 메소드
	void get_hp() {
		std::cout << hp << " 의 체력을 가집니다." << std::endl;
	}

public:
    // pokemon 클래스의 public 변수
	int attack;

    // pokemon 클래스의 public 메소드
	void get_attack() {
		std::cout << attack<<" 의 공격력을 가집니다." << std::endl;
	}

}; //pokemon 클래스
```

포켓몬을 사랑하는 사람들이 봤을 때, 화를 낼 수 있다.

왜냐하면, 포켓몬은 나이, 키, 몸무게 등 다른 속성도 가지고, 행동도 공격뿐만 아니라 자기도 하고, 밥도 먹고, 산책도 할 수도 있기 때문이다.

당연히 현실 세계의 모든 내용을 클래스로 표현할 수는 없다.

이 과정에서 **필요한 행동과 변수만 추려서 클래스로 만드는 과정**은 불가피하고, 이를 **추상화**라고 한다.

추상화의 장점으로는 **복잡성을 감소**시키고, 제대로 추상화했다면 메소드 간의 중복되는 역할이 없을 테니 메소드 자체의 **재사용성 증가**, 어떤 메소드만 수정 해야한다면 그 메소드만 수정하면 되기 때문에 **유지보수의 용이** 등이 있다.

다음 시간에는 **생성자와 오버로딩**에 대해 알아보겠다.

---

<h2>📖 오늘의 핵심(다 알기 전까지는 넘어가지 말자❗)</h2>

✅ 1. 캡슐화가 무엇인지 알고, 그 장점이 무엇인지 안다.

✅ 2. 추상화가 무엇인지 알고, 그 장점이 무엇인지 안다.

💣 과제,

1. 없음

🔜 더 공부해보기,

<a href = "https://www.educba.com/abstraction-vs-encapsulation/">읽어볼 거리(1) - 그림으로 보는 캡슐화와 추상화</a>
