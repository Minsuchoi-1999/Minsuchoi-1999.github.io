---
date: 2024-04-04 09:24:52
layout: post
title: "객체지향프로그래밍(23) - 연산자 오버로딩(2), 산술대입연산자와 조건 연산자"
subtitle: "단항 연산자와 산술 연산자의 오버로딩"
description: 여러 종류의 연산자 오버로딩을 이해한다.
image: https://res.cloudinary.com/dtloik0ts/image/upload/v1710305020/62209a189cc9185b70db045b_6ea4ua9rZnloCziXgO4TM7Zqa5oWwYrMD4Lc5BqWGYHrJreJ0-Cq-VTOChRhm1IEhqCGeGpQh9M8L516rerUQF9l1FnfQaHEFyTzex7ily50AmFoRns3jMWLyd5edWCJqBbqGzvo_xaa8bg.jpg
optimized_image: https://res.cloudinary.com/dtloik0ts/image/upload/t_opt/v1710305020/62209a189cc9185b70db045b_6ea4ua9rZnloCziXgO4TM7Zqa5oWwYrMD4Lc5BqWGYHrJreJ0-Cq-VTOChRhm1IEhqCGeGpQh9M8L516rerUQF9l1FnfQaHEFyTzex7ily50AmFoRns3jMWLyd5edWCJqBbqGzvo_xaa8bg.jpg
category: 객체지향프로그래밍
tags:
  - 정리
  - 객체지향프로그래밍
author: Minsu Choi
paginate: false
---

<h2>🔚 짧게 하는 복습</h2>

✅ 1. 단항 연산자의 오버로딩을 할 수 있다.

✅ 2. 산술 연산자의 오버로딩을 할 수 있다.

✅ 3. 오버로딩 산술 연산자의 호출 원리를 이해한다.

혹시 기억이 안 난다면, <u><a href = "/객체지향프로그래밍(22)-연산자-오버로딩(1),-단항-연산자와-산술-연산자/"> 다시 돌아가자</a></u>

---

저번 시간에는 연산자 오버로딩 중 단항 연산자와 산술 연산자의 오버로딩에 대해 다루어 보았다.

이번 시간은, 저번 시간에 이어 산술 대입연산자와 조건 연산자의 오버로딩에 대해서도 알아보겠다.

---

## 산술 대입 연산자

**산술 대입 연산자**는 산술과 대입을 동시에 하는 연산자로, **+=, -=, \*=** 등이 있었다.

이 역시 오버로딩이 가능한데 좀 더 재밌는 예시 코드로 준비해보았다.

우선 코드를 보자.

<iframe style='max-width:100%; border: none; height: 375px; width: 700px;' height=375 width=700 src="https://www.interviewbit.com/embed/snippet/0e2519f5ee90f9fd7f32"></iframe>

카운터가 limit이 넘어가면 초기화되는 코드를 만들었다.

이렇게 연산자 오버로딩의 장점은 **단순히 클래스 혹은 구조체끼리 연산을 가능하게 한다는 점**뿐 아니라, 개발자가 원하는 **추가적인 기능을 탑재할 수 있다는 점**이다.

---

## 논리연산자

다음은 **논리연산자**이다. 여기에는 **!, >, <, ==** 등이 있다.

위의 예제에서 카운트의 숫자가 얼마를 넘는지, 같은지, 0인지 등을 오버로딩을 통해 구현해보겠다.

참고로 논리연산자 자체에서는 값이 비교가 보통 안 돼서, **const**를 많이 사용한다.

<iframe height="1500px" width="700px" src="https://www.interviewbit.com/embed/snippet/e115791e91832a1b08aa"></iframe>

! 연산자의 경우, 아예 원래 있던 용도와 무관하게 바꿔버렸다.

이렇게 **유연한 코딩이 가능하게 하는 것**, 쉽게 말하면 **다형성을 제공하는 것**이 연산자 오버로딩의 특징이다.

하지만 **직관적으로 이해가 되지 않을 정도**로 원래의 용도와 바꾸면 오히려 **가독성을 해칠 수 있다.**

---

## 이 밖에도….

이 밖에도 다른 대부분의 연산자가 오버로딩이 가능하다.

예를 들어, cin과 cout에서 사용하는 <<, >> 역시 오버로딩으로 정의된 것이며, string에서 제공하는 덧셈, 비교 연산 역시 오버로딩을 제공된다.

또, 배열의 참조 연산자인 []도 오버로딩이 가능하다.

하지만 그런데도 오버로딩 자체를 불가능하게 한 연산자가 있다.

멤버 변수 혹은 메소드에 접근하게 하는 **.연산자**, 범위를 정해주는 범위 지정자 **::연산자**, 구조체 포인터 혹은 클래스 포인터에서 사용하는 **->연산자**는 오버로딩이 불가능하다.

대표적인 삼항 연산자인 **조건 연산자(?:)**도 오버로딩 할 수 없다.

---

✅ 1. 산술 대입연산자의 오버로딩을 할 수 있다.

✅ 2. 조건 연산자의 오버로딩을 할 수 있다.

✅ 3. 그 밖에도 다른 연산자들도 오버로딩을 할 수 있다.

⚠️ .연산, ::연산, ->연산, ?:연산은 오버로딩할 수 없다.

💣 과제,

1. ==(같은 문자열인지), >(알파벳 순서로 늦는지), <(알파벳 순서로 빠른지), <<(입력), >>(출력) 등을 이용해 나만의 string 클래스를 구현해보자. (난이도 上)
